// src/utils/csrf.ts
import { doubleCsrf } from 'csrf-csrf';
import type { APIContext } from 'astro';
import type { CloudflareEnv } from '../env'; // Assumes csrf.ts is in src/utils/

// Define the shape of CSRF utilities returned by doubleCsrf
type CsrfLibraryUtils = ReturnType<typeof doubleCsrf>;

// Singleton instance for CSRF utilities
let csrfUtilsInstance: CsrfLibraryUtils | null = null;

const DEFAULT_CSRF_FALLBACK_SECRET =
  'unsafe-fallback-dev-secret-must-be-at-least-32-bytes-long-for-csrf';

/**
 * Initializes and returns CSRF utility functions using a singleton pattern.
 * @param env - The runtime environment containing secrets and configurations.
 * @returns An object with CSRF utility functions.
 */
function getCsrfUtils(env: CloudflareEnv): CsrfLibraryUtils {
  if (csrfUtilsInstance) {
    return csrfUtilsInstance;
  }

  let secret = env.CSRF_SECRET;

  if (!secret || secret.length < 32) {
    secret = DEFAULT_CSRF_FALLBACK_SECRET;
    if (env.ENVIRONMENT === 'production' || !import.meta.env.DEV) {
      console.error(
        'CRITICAL CSRF Setup Error: CSRF_SECRET is missing or too short in a production-like environment. Using an insecure fallback.'
      );
    } else {
      console.warn(
        `CSRF Setup Warning: Using fallback CSRF_SECRET. THIS IS INSECURE. Ensure CSRF_SECRET is properly set for development in .dev.vars and for production in Cloudflare secrets.`
      );
    }
  }

  const csrfLibUtils = doubleCsrf({
    getSecret: () => secret,
    getSessionIdentifier: (req: Request): string => {
      const isProdLike = env.ENVIRONMENT === 'production';
      const sessionCookieName = isProdLike
        ? "__Secure-authjs.session-token"
        : "authjs.session-token";

      const cookiesHeader = req.headers.get('cookie');
      if (cookiesHeader) {
        const cookies = cookiesHeader.split('; ');
        const sessionCookie = cookies.find(c => c.startsWith(`${sessionCookieName}=`));
        if (sessionCookie) {
          const sessionTokenValue = sessionCookie.split('=')[1];
          if (sessionTokenValue && sessionTokenValue.length > 10) {
            return sessionTokenValue;
          }
        }
      }
      return "__anonymous_csrf_session__";
    },
    cookieName: env.ENVIRONMENT === 'production' ? '__Host-csrf.secret' : 'csrf.secret',
    cookieOptions: {
      path: '/',
      secure: env.ENVIRONMENT === 'production',
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 60 * 60 * 2, // 2 hours in seconds
    },
    size: 64,
  });

  csrfUtilsInstance = csrfLibUtils;
  return csrfUtilsInstance;
}

export async function prepareCsrfToken(context: APIContext): Promise<string> {
  const env = context.locals.runtime?.env as CloudflareEnv | undefined;

  if (!env) {
    const errorMessage = 'CSRF Prep: CloudflareEnv missing from context.locals.runtime. Cannot prepare CSRF token.';
    console.error(errorMessage);
    if (import.meta.env.DEV) return 'dev-csrf-token-env-missing';
    throw new Error('Server configuration error: Runtime environment not found for CSRF preparation.');
  }

  const { generateToken } = getCsrfUtils(env);
  const dummyResponse = new Response(null);

  try {
    const csrfToken = generateToken(context.request, dummyResponse, true);
    const setCookieHeader = dummyResponse.headers.get('set-cookie');

    if (setCookieHeader) {
      const cookieParts = setCookieHeader.split(';').map(part => part.trim());
      const [nameValue, ...optionsArray] = cookieParts;
      const [cookieName, cookieValue] = nameValue.split('=');
      const astroCookieOptions: Record<string, any> = {
        httpOnly: true,
        secure: env.ENVIRONMENT === 'production',
        path: '/',
        sameSite: 'lax',
      };
      optionsArray.forEach(part => {
        const [key, ...valParts] = part.split('=');
        const value = valParts.join('=');
        if (key.toLowerCase() === 'max-age' && value) {
          astroCookieOptions.maxAge = parseInt(value, 10);
        }
        if (key.toLowerCase() === 'expires' && value) {
           astroCookieOptions.expires = new Date(value);
        }
      });
      if (astroCookieOptions.maxAge === undefined && astroCookieOptions.expires === undefined) {
        astroCookieOptions.maxAge = 60 * 60 * 2;
      }
      context.cookies.set(cookieName, cookieValue, astroCookieOptions);
    } else {
      console.warn("CSRF Prep: 'set-cookie' header for CSRF secret was not generated by csrf-csrf library.");
    }
    return csrfToken;
  } catch (error) {
    console.error('CSRF token generation error:', error);
    if (import.meta.env.DEV) {
      return 'dev-csrf-token-error-' + Math.random().toString(36).substring(2, 9);
    }
    throw new Error('Failed to generate CSRF token.');
  }
}

export async function validateCsrfRequest(
  contextOrRequest: APIContext | Request,
  envOverride?: CloudflareEnv
): Promise<boolean> {
  const request = (contextOrRequest as APIContext).request || (contextOrRequest as Request);
  const env = envOverride || (contextOrRequest as APIContext).locals?.runtime?.env as CloudflareEnv | undefined;

  if (!env) {
    console.error('CSRF Valid: CloudflareEnv missing. CSRF validation cannot proceed.');
    return false;
  }

  try {
    const { validateRequest } = getCsrfUtils(env);
    // FIXED: validateRequest from csrf-csrf typically only takes the request object.
    const isValid = validateRequest(request);

    if (!isValid) {
      console.warn(
        `CSRF token validation failed for: ${request.method} ${new URL(request.url).pathname}`
      );
    }
    return isValid;
  } catch (error) {
    console.error('Error during CSRF validation:', error);
    return false;
  }
}